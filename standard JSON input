{"language":"Solidity","sources":{"contracts/main.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts@4.7.0/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts@4.7.0/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts@4.7.0/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts@4.7.0/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts@4.7.0/access/Ownable.sol\";\nimport \"./myPet.sol\";\nimport \"./core.sol\";\nimport \"./Metadata.sol\";\n/**\n * @title IERC2981\n * @dev Interface for the ERC2981: NFT Royalty Standard extension, which extends the ERC721 standard.\n */\ninterface IERC2981 is IERC165 {\n\n  /**\n   * @notice Called with the sale price to determine how much royalty is owed and to whom.\n   * @param _tokenId - The ID of the NFT asset queried for royalty information.\n   * @param _salePrice - The sale price of the NFT asset specified by _tokenId.\n   * @return receiver - Address of who should be sent the royalty payment.\n   * @return royaltyAmount - The royalty payment amount for _salePrice.\n   */\n  function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view\n    returns (address receiver, uint256 royaltyAmount);\n} \n\ninterface ContractArtifactInterface {\n    function rewardSystem (uint8[4] calldata , address , uint) external;\n    function getEquipedArtifactsEffects(address) external view returns (uint32[4] memory);\n}\n\n\n\n\n\ncontract Main is ERC721Enumerable, ERC721Burnable, Ownable {\n    constructor() ERC721(\"FantomAdventureRPG\", \"FARPG\") {\n        setImageURL(\"https://ipfs.io/ipfs/QmTuURiwRkvk6CSLGDphTcTVqjhVNyz2yfPzcdBkzGNmvY/\");\n        setImageExtension(\".gif\");\n    \n    }\n    \n   //----------------------- Overribes Functions ---------------------------------------\n    /**\n    * @dev Overrides the _beforeTokenTransfer function from ERC721 and ERC721Enumerable.\n    * @param from - The address from which the token will be transferred.\n    * @param to - The address to which the token will be transferred.\n    * @param tokenId - The ID of the token to be transferred.\n    */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) \n        internal virtual override(ERC721, ERC721Enumerable) {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n    * @dev Checks if the contract implements the ERC2981 interface and returns true if it does.\n    * @param interfaceId - The interface ID to check for support.\n    * @return A boolean indicating whether the contract supports the ERC2981 interface or not.\n    */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) \n        returns (bool) {\n        return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\n    }\n    //----------------------------------------------------------------------------\n\n    uint16 private constant MAX_MINTABLE = 9999;\n    uint16 private constant MAX_PER_ATTEMPT = 5;\n    uint16 private constant MINTPRICE = 0;\n    \n    uint16 private constant BATTLESTAMINA = 2 minutes;\n    \n\n    uint256 private tokenIdTracker;\n\n    string public baseTokenURI; //in case metadata server/IPFS dead before FTM\n    string public imageURL; //in case image server/IPFS dead before FTM\n    string public imageExtension;\n    bool public namebyID = true;\n    \n    //TowerLevel 0 is havent start. 1 to 20 is level one.\n    // 21 to 40 is level two, and so on. to 181 to 200 for level 10. \n    mapping (address => uint8) public TowerLevel; \n    mapping (address => uint32) public TowerResetCd; \n    mapping (uint => uint8) public DailyMaxReward;\n    mapping (uint => uint64) public RewardLimitTimer;\n    A.Pets[MAX_MINTABLE] public Pet;\n\n    // artifact contract, that can be used to reward players from this contract\n    ContractArtifactInterface ArtifactContract; //need global, other functions need it.\n    bool confirmed;\n\n\n    event Result(uint256 indexed id, bool won, uint256 hash, A.Pets selfOrBefore, A.Pets opponOrAfter, uint64 damage, uint bit);\n    event StatChangedResult(A.Pets AfterMon);\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n    //--------------------------------- MINTING FUNCTIONS ------------------------------------\n    /**\n    * @dev Mints a new Pet to the specified address.\n    *\n    * @param _to The address to mint the Pet to.\n    */\n    function _mint(address _to) private {\n        // Get the next available token ID.\n        uint id = tokenIdTracker;\n        tokenIdTracker++;\n\n        // Generate a random number for the Pet's attributes.\n        uint _rand = uint(keccak256(abi.encodePacked(msg.sender, block.timestamp,block.coinbase)));\n\n        // Mint the Pet.\n        Pet[id] = core.mintEgg(_rand >> ((tokenIdTracker % 50) * 3)); //>>((tokenIdTracker%15)*3)\n        Pet[id].attribute.id = uint16(id);\n        _safeMint(_to, id);\n\n        // Emit a StatChangedResult event.\n        emit StatChangedResult(Pet[id]);\n    }\n\n    function isContractAddress(address _address) internal view returns (bool) {\n        uint32 size;\n        assembly {\n         size := extcodesize(_address)\n        }\n        return (size > 0);\n    }\n\n    function mint(address _to, uint256 _count) public payable {\n    // Check that the total number of Pets to mint does not exceed the maximum.\n        require(!isContractAddress(msg.sender), \"Contract addresses are not allowed\");\n        require(balanceOf(_to) <= 20, \"MAXIMUM MINT 20 EGGS PER ADDRESS FOR NOW\");\n        require((tokenIdTracker + _count <= MAX_MINTABLE) && //error.exceed total MAX mintable\n                (_count <= MAX_PER_ATTEMPT) && //error.exceed multi-mint max limit\n                (msg.value >= _count * MINTPRICE)); //error.less than needed total mint cost\n\n        // Mint the Pets.\n        for (uint256 i = 0; i < _count; i++) {\n            _mint(_to);\n        }\n    }\n\n    //----------------------- Raise Functions ---------------------------------------\n    function HatchEgg(uint _id) public { //owner,trainer check in function\n        Pet[_id] = core.HatchEgg(Pet[_id], ownerOf(_id));\n    }\n    function feedsPet(uint _id, uint8 _foodtype) public payable { //owner,trainer check in function\n        Pet[_id] = core.FeedPet(Pet[_id], _foodtype,ownerOf(_id)); //requirement check on lib\n        emit StatChangedResult(Pet[_id]);\n    }\n    function trainsPet(uint _id, uint8 _trainingtype) public { //owner,trainer check in function\n        Pet[_id] = core.trainPet(Pet[_id], _trainingtype,ownerOf(_id)); //requirement check on lib\n        emit StatChangedResult(Pet[_id]);\n    }\n    struct cc {\n        uint8[4] _chances; \n        uint32[4] ABCD;\n        uint BattleRhythm;\n        uint64 damage; //dealt total damage to Mon2\n         uint8 bit; // how many bit has been filled for Rythm\n    }\n    function BattlePet(uint _id, uint8 _rank) public {\n        //_rank 0~3 is AI based on self CP. \n        //_rank 4 = mysterious tower has 10 level.\n        require(!isContractAddress(msg.sender), \"Contract addresses are not allowed\");\n        A.Pets memory OwnerPet = Pet[_id];\n        uint64 _timenow = uint64(block.timestamp);\n        require(msg.sender == ownerOf(_id)  &&\n                _timenow - OwnerPet.time.stamina >= BATTLESTAMINA && \n                OwnerPet.time.deadtime > _timenow && OwnerPet.time.endurance > _timenow ); //Alive\n        bool Mon1Win;\n        cc memory C;\n //       uint BattleRhythm;\n //       uint8 bit; // how many bit has been filled for Rythm\n //       uint64 damage; //dealt total damage to Mon2\n //       uint8[4] memory _chances;\n //       uint32[4] memory ABCD;\n        uint8 _nextTowerLevel;\n        uint rand = uint(keccak256(abi.encodePacked(msg.sender, block.timestamp)));\n        A.Pets memory BattlingPet;\n        C.ABCD = ArtifactContract.getEquipedArtifactsEffects(msg.sender);\n        if (_rank <= 3) { //tag along with Mon1Win to reduce stack\n            BattlingPet = core.battlingPet(_rank,rand);\n        } else {\n            require(TowerLevel[msg.sender] > 0, \"TowerLevel 0\");\n            (BattlingPet,C._chances,_nextTowerLevel) = core.TowerPet(TowerLevel[msg.sender], rand);\n        }\n        OwnerPet.power.hitpoints = OwnerPet.power.hitpoints + (C.ABCD[0]*1000);\n        OwnerPet.power.strength = OwnerPet.power.strength + uint16(C.ABCD[1]);\n        OwnerPet.power.agility = OwnerPet.power.agility + uint16(C.ABCD[2]);\n        OwnerPet.power.intellegence = OwnerPet.power.intellegence+ uint16(C.ABCD[3]);\n        (Mon1Win,C.BattleRhythm, C.bit, C.damage) = core.battlePet(rand, OwnerPet, BattlingPet);\n        \n        if (_rank >3 && Mon1Win == true) {\n        TowerLevel[msg.sender] = _nextTowerLevel; //win go to next\n        //Give reward with chances if win here!\n            if (DailyMaxReward[_id] > 0) { //reach reward limit?\n                ArtifactContract.rewardSystem(C._chances, msg.sender, rand);\n                DailyMaxReward[_id] = DailyMaxReward[_id] -1;\n            } else if( _timenow - RewardLimitTimer[_id] > 82800 ) {//23hours //help reset limit and use it\n                ArtifactContract.rewardSystem(C._chances, msg.sender, rand);\n                DailyMaxReward[_id] = 9;\n                RewardLimitTimer[_id] = _timenow;\n            } //otherwise, no reward.\n        }\n        \n        Pet[_id] = core.battlewinlosereward(Pet[_id], Mon1Win, _rank); //exp stars gain   \n        Pet[_id].time.stamina += BATTLESTAMINA; // take up stamina\n        emit Result(_id, Mon1Win, C.BattleRhythm, Pet[_id], BattlingPet,C.damage, C.bit); //done battle\n        \n    }\n    \n    function resetTowerLevel() public {\n        if (block.timestamp - TowerResetCd[msg.sender] > 50) { //50s cooldown for reset the level to prevent spam\n            TowerLevel[msg.sender] = (uint8(uint(keccak256(abi.encodePacked(msg.sender, block.timestamp,block.coinbase))))%20)+1;\n            TowerResetCd[msg.sender] = uint32(block.timestamp);\n        } else {\n            revert();\n        }\n    }\n    \n    function setArtifactContract (address _artifact) public onlyOwner {\n        if (confirmed == false) {\n            ArtifactContract = ContractArtifactInterface(_artifact);\n        }\n    }\n     \n    function confirmArtifactContract () public onlyOwner {\n        confirmed = true;\n    }\n\n\n\n    //----------------------- Owner function ---------------------------------\n    function withdraw(address payable _to) external { //incase someone want to donate to me? who knows. haha\n        require(_to == owner());\n        (bool sent,) = _to.call{value: address(this).balance}(\"\");\n        require(sent);\n    }\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        baseTokenURI = baseURI; //IPFS/server is less realiable than FTM IMO. The states are safe in FTM. Only URI link is upgradable.\n        //URI is just for marketplace to display.\n    }\n    function setImageURL(string memory URL) public onlyOwner {\n        imageURL = URL;//IPFS/server is less realiable, Only URI link is upgradable.\n        //URI is just for marketplace to display.\n    }\n    function setImageExtension(string memory ext) public onlyOwner {\n        imageExtension = ext; //IPFS/server is less realiable, Only URI link is upgradable.\n        //URI is just for marketplace to display.\n    }\n    function setnamebyID(bool TF) public onlyOwner {\n        namebyID = TF; //IPFS/server is less realiable, Only URI link is upgradable.\n        //URI is just for marketplace to display.\n    }\n    //----------------------- Free read Functions ---------------------------------------\n    function royaltyInfo(uint, uint _salePrice) external view returns (address, uint) {\n        uint royalty = 500;\n        address receiver = owner();\n        return (receiver, (_salePrice * royalty) / 10000);\n    }\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseTokenURI;\n    }\n    function _imageURI() internal view returns (string memory) {\n        return imageURL;\n    }\n    function viewNFT(uint256 _tokenId) external view returns (A.Pets memory) {\n        return Pet[_tokenId];\n    }\n    function getPetsByOwner(address _owner) public view returns(uint[] memory) {\n        uint[] memory result = new uint[](balanceOf(_owner));\n        uint counter = 0;\n        for (uint i = 0; i < tokenIdTracker; i++) {\n            if (ownerOf(i) == _owner) {\n                result[counter] = i;\n                counter++;\n            }\n        }\n        return result;\n    }\n    function getPetsByOwnerByBatch (address _owner) external view returns(A.Pets[] memory) {\n        uint[] memory ids = getPetsByOwner(_owner);\n        A.Pets[] memory PetsInfo = new A.Pets[](balanceOf(_owner));\n        for (uint i = 0; i < balanceOf(_owner); i++) {\n            PetsInfo[i] = Pet[ids[i]];\n        }\n        return PetsInfo;\n    }\n    \n    function tokenURI(uint256 tokenId) public view override virtual returns (string memory) {\n        _requireMinted(tokenId);\n        //E.toString(tokenId)\n        return Meta.buildURIbased64(Pet[tokenId],imageURL, imageExtension,uint64(block.timestamp),namebyID);\n    } //I wish Marketplaces able to comply to this...\n    function viewTowerMonster(address _owner) public view returns (A.Pets memory APet, uint8[4] memory _chances){\n        (APet,_chances,) = core.TowerPet(TowerLevel[_owner],0);\n    }\n    function DailyRewardLimit (uint _id) public view returns(uint8 Limit, uint64 resettimer) {\n        if (DailyMaxReward[_id] > 0) {\n                Limit = DailyMaxReward[_id];\n                resettimer = RewardLimitTimer[_id];\n            } else if( block.timestamp - RewardLimitTimer[_id] > 82800 ) {//23hours\n                Limit = 10;\n                resettimer = uint64(block.timestamp);\n            } else {\n                Limit = DailyMaxReward[_id];\n                resettimer = RewardLimitTimer[_id];\n            }\n    }\n\n\n\n}\n"},"contracts/Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.2;\n\nimport \"./myPet.sol\";\nimport \"./base64.sol\";\nlibrary Meta {\n\n    uint64 private constant FULL_STAMINA = 40 minutes; //core has record too\n  \n    function buildURIbased64(A.Pets memory _Pet, string memory _imageURI, string memory _imageExt,uint64 _timenow,bool _namebyID) \n    external pure returns (string memory metadata) {\n        string memory _name;\n        string memory _imagelinkfull;\n        string memory _description;\n        string memory _attribute1;\n        string memory _attribute2;\n        string memory _attribute3;\n        string memory _attribute4;\n        (_name,_description) = _getNameDescription(_Pet.species);\n        _attribute1 = _getAttribute1(_Pet,_timenow);\n        _attribute2 = _getAttribute2(_Pet);\n        _attribute3 = _getAttribute3(_Pet);\n        _attribute4 = _getAttribute4(_Pet);\n        _imagelinkfull = string(abi.encodePacked(_imageURI,_toString(_Pet.species),_imageExt));\n        if (_namebyID == true) {\n             metadata = string(abi.encodePacked(\"data:application/json;base64,\",\n                Base64.encode(\n                    bytes(\n                        abi.encodePacked(\n                            \"{\\\"name\\\": \\\"#\",_toString(_Pet.attribute.id),\" \",_name,\n                            \"\\\",\\\"description\\\": \\\"\",_description,\n                            \"\\\",\\\"image\\\": \\\"\",\n                            _imagelinkfull,\n                            _attribute1,_attribute2,_attribute3,_attribute4     \n                        )\n                    )\n                )\n            ));\n        } else {\n            metadata = string(abi.encodePacked(\"data:application/json;base64,\",\n                Base64.encode(\n                    bytes(\n                        abi.encodePacked(\n                            \"{\\\"name\\\": \\\"\",_name,\n                            \"\\\",\\\"description\\\": \\\"\",_description,\n                            \"\\\",\\\"image\\\": \\\"\",\n                            _imagelinkfull,\n                            _attribute1,_attribute2,_attribute3,_attribute4     \n                        )\n                    )\n                )\n            ));\n        }\n    }\n\n\n\n    function _toString(uint _i) private pure returns (bytes memory convString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return bstr;\n    }\n    function sqrt32b(uint32 y) private pure returns (uint32 z) {\n        if (y > 3) {\n            z = y;\n            uint32 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n    function _returnLevel(uint32 _exp) private pure returns (uint32 _level){\n        _level= sqrt32b(_exp)/258 + 1; //min level 1 - max level 255\n        \n    }\n\n    function _getAttribute1(A.Pets memory _Pet, uint64 _timenow) private pure returns (string memory attribute){\n        \n        string memory _stage;\n        \n        \n        uint64 _endurance;\n      \n        uint64 _stamina;\n        uint64 _diffTime;\n\n       \n        if (_Pet.attribute.stage == 0) {_stage = \"Egg\"; }\n        else if (_Pet.attribute.stage == 1) {_stage = \"Youth\"; }\n        else if (_Pet.attribute.stage == 2) {_stage = \"Rookie\"; }\n        else if (_Pet.attribute.stage == 3) {_stage = \"Matured\"; }\n            else {_stage = \"Perfect\"; }\n        \n        if (_Pet.status == 1) { /*frozen Pet time has to offset*/\n            _diffTime = _timenow-_Pet.time.frozentime;\n            _Pet.time.endurance = _Pet.time.endurance+(_diffTime);\n            _Pet.time.evolutiontime = _Pet.time.evolutiontime+(_diffTime);\n            _Pet.time.deadtime = _Pet.time.deadtime+(_diffTime);\n            _Pet.time.stamina = _Pet.time.stamina+(_diffTime);\n        }\n\n        if (_Pet.time.endurance <= _timenow) {  _endurance=0; }\n            else {_endurance = _Pet.time.endurance - _timenow; }\n        \n        if (_Pet.time.stamina >= _timenow) {  _stamina=0; }\n            else {_stamina = _timenow - _Pet.time.stamina ; \n                    if (_stamina > FULL_STAMINA){_stamina = FULL_STAMINA;}\n                    \n                }\n        attribute = string(abi.encodePacked(\n            \"\\\",   \\\"attributes\\\": [{\\\"trait_type\\\": \\\"'Stage\\\",\\\"value\\\": \\\"\",bytes(_stage),\n //               \\\"trait_type\\\": \\\"Status\\\",\\\"value\\\": \\\"\",bytes(_status),   //cut feature due to time line for hackathon\n //           \"\\\"}, {\\\"trait_type\\\": \\\"Shinning\\\",\\\"value\\\": \\\"\",bytes(_shinning),   //cut feature due to time line for hackathon\n //           \"\\\"}, {\n             \"\\\"}, {\\\"trait_type\\\": \\\"'Species\\\",\\\"value\\\": \\\"\",_toString(_Pet.species),   \n            \"\\\"}, {\\\"trait_type\\\": \\\"'Family\\\",\\\"value\\\": \\\"\",_getFamily(_Pet.family),   //cut feature due to time line for hackathon\n            \"\\\"}, {\\\"trait_type\\\": \\\"_Endurance\\\",\\\"value\\\": \\\"\",_getDayHrsMin(_endurance),\n            \"\\\"}, {\\\"trait_type\\\": \\\"_Stamina\\\",\\\"value\\\": \\\"\",_getDayHrsMin(_stamina)\n            \n        ));\n    } //divided into function2 as stack too deep.\n     function _getAttribute2(A.Pets memory _Pet) private pure returns (string memory attribute){\n        attribute = string(abi.encodePacked(\n            \"\\\"}, {\\\"trait_type\\\": \\\":::Level\\\",\\\"value\\\": \\\"\",_toString(_returnLevel(_Pet.exp)),\n            \"\\\"}, {\\\"trait_type\\\": \\\"::HP\\\",\\\"value\\\": \\\"\",_toString(_Pet.power.hitpoints),\n            \"\\\"}, {\\\"trait_type\\\": \\\"::STR\\\",\\\"value\\\": \\\"\",_toString(_Pet.power.strength),\n            \"\\\"}, {\\\"trait_type\\\": \\\":AGI\\\",\\\"value\\\": \\\"\",_toString(_Pet.power.agility),\n            \"\\\"}, {\\\"trait_type\\\": \\\":INT\\\",\\\"value\\\": \\\"\",_toString(_Pet.power.intellegence),     \n            \"\\\"}, {\\\"trait_type\\\": \\\"Happiness\\\",\\\"value\\\": \\\"\",_toString(_Pet.attribute.happiness)\n            \n        ));\n    }//divided into function3 as stack too deep.\n    function _getAttribute3(A.Pets memory _Pet) private pure returns (string memory attribute){      \n        attribute = string(abi.encodePacked(       \n            \"\\\"}, {\\\"trait_type\\\": \\\"Discipline\\\",\\\"value\\\": \\\"\",_toString(_Pet.attribute.discipline),\n            \"\\\"}, {\\\"trait_type\\\": \\\"Weight(g)\\\",\\\"value\\\": \\\"\",_toString(_Pet.attribute.weight),          \n            \"\\\"}, {\\\"trait_type\\\": \\\"_Trait1\\\",\\\"value\\\": \\\"\",_getTraits(_Pet.trait[0]),\n            \"\\\"}, {\\\"trait_type\\\": \\\"_Trait2\\\",\\\"value\\\": \\\"\",_getTraits(_Pet.trait[1]),\n            \"\\\"}, {\\\"trait_type\\\": \\\"_Trait3\\\",\\\"value\\\": \\\"\",_getTraits(_Pet.trait[2])\n        ));\n    }//divided into function4 as stack too deep.\n    function _getAttribute4(A.Pets memory _Pet) private pure returns (string memory attribute){      \n        attribute = string(abi.encodePacked(                 \n            \"\\\"}, {\\\"trait_type\\\": \\\"_Skill1\\\",\\\"value\\\": \\\"\",_getSkills(_Pet.skill[0]),\n            \"\\\"}, {\\\"trait_type\\\": \\\"_Skill2\\\",\\\"value\\\": \\\"\",_getSkills(_Pet.skill[1]),\n            \"\\\"}, {\\\"trait_type\\\": \\\"_Skill3\\\",\\\"value\\\": \\\"\",_getSkills(_Pet.skill[2]),\n//            \"\\\"}, {\\\"trait_type\\\": \\\"Genetic\\\",\\\"value\\\": \\\"\",_toString(_Pet.gene),  //cut feature due to time line for hackathon\n            \"\\\"}]}\" \n        ));\n    }\n\n    function _getFamily(uint16 _family) private pure returns (bytes memory family){\n        string memory familytemp;\n        if (_family == 0) {familytemp = \"Distinction\"; }\n        else if (_family == 1) {familytemp = \"Celestial\"; }\n        else if (_family == 2) {familytemp = \"Verdant\"; }\n        else if (_family == 3) {familytemp = \"Fantasy\"; }\n        else if (_family == 4) {familytemp = \"Abyss\"; }\n        family = bytes(familytemp);\n    }\n    function _getTraits(uint8 _trait) private pure returns (bytes memory trait){\n        string memory traittemp;\n        if (_trait == 0) {traittemp = \"none\"; }\n        else if (_trait == 1) {traittemp = \"Tough\"; }\n        else if (_trait == 2) {traittemp = \"Brawler\"; }\n        else if (_trait == 3) {traittemp = \"Nimble\"; }\n        else if (_trait == 4) {traittemp = \"Smart\"; }\n        else if (_trait == 5) {traittemp = \"Pride\"; }\n        else if (_trait == 6) {traittemp = \"Resilient\"; }\n        else if (_trait == 7) {traittemp = \"Hardworking\"; }\n        else if (_trait == 8) {traittemp = \"Serious\"; }\n        else if (_trait == 9) {traittemp = \"Creative\"; }\n        else if (_trait == 10) {traittemp = \"Ambitious\"; }\n        else if (_trait == 11) {traittemp = \"Multitasking\"; }\n        else if (_trait == 12) {traittemp = \"Lonely\"; }\n        else if (_trait == 13) {traittemp = \"Bashful\"; }\n        else if (_trait == 14) {traittemp = \"Adamant\"; }\n        else if (_trait == 15) {traittemp = \"Naughty\"; }\n        else if (_trait == 16) {traittemp = \"Brave\"; }\n        else if (_trait == 17) {traittemp = \"Timid\"; }\n        else if (_trait == 18) {traittemp = \"Hasty\"; }\n        else if (_trait == 19) {traittemp = \"Jolly\"; }\n        else if (_trait == 20) {traittemp = \"Naive\"; }\n        else if (_trait == 21) {traittemp = \"Quirky\"; }\n        else if (_trait == 22) {traittemp = \"Mild\"; }\n        else if (_trait == 23) {traittemp = \"Quiet\"; }\n        else if (_trait == 24) {traittemp = \"Rash\"; }\n        else if (_trait == 25) {traittemp = \"Modest\"; }\n        else if (_trait == 26) {traittemp = \"Docile\"; }\n        else if (_trait == 27) {traittemp = \"Relaxed\"; }\n        else if (_trait == 28) {traittemp = \"Bold\"; }\n        else if (_trait == 29) {traittemp = \"Impish\"; }\n        else if (_trait == 30) {traittemp = \"Lax\"; }\n        else if (_trait == 31) {traittemp = \"Careful\";}\n        else {traittemp = \"none\";}\n        trait = bytes(traittemp);\n    }\n    function _getSkills(uint8 _skill) private pure returns (bytes memory skill){\n        string memory skilltemp;\n        //skill start at Rookie\n        if (_skill == 10) {skilltemp = \"Air Wave - X\"; }\n        else if (_skill == 11) {skilltemp = \"Force Palm\"; }\n        else if (_skill == 12) {skilltemp = \"Rock Throw\"; }\n        else if (_skill == 13) {skilltemp = \"Fur Sting\"; }\n        else if (_skill == 14) {skilltemp = \"Fire Ball\"; }\n        else if (_skill == 15) {skilltemp = \"Gust\"; }\n        else if (_skill == 16) {skilltemp = \"Air Wave - Y\"; }\n        else if (_skill == 17) {skilltemp = \"Air Wave - Z\"; }\n        else if (_skill == 18) {skilltemp = \"Metal Scale\"; }\n        else if (_skill == 19) {skilltemp = \"Blade Energy\"; }\n        else if (_skill == 20) {skilltemp = \"Fire Tornado\"; }\n        else if (_skill == 21) {skilltemp = \"Shadowball\"; }\n        else if (_skill == 22) {skilltemp = \"Leaf Blade\"; }\n        else if (_skill == 23) {skilltemp = \"Flame Thrower - X\"; }\n        else if (_skill == 24) {skilltemp = \"Wicked Slash\"; }\n        else if (_skill == 25) {skilltemp = \"Discharge\"; }\n        else if (_skill == 26) {skilltemp = \"Frost Blast\"; }\n        else if (_skill == 27) {skilltemp = \"Buble Wrap\"; }\n        else if (_skill == 28) {skilltemp = \"Spinning Slash\"; }\n        else if (_skill == 29) {skilltemp = \"Echo scream\"; }\n        else if (_skill == 30) {skilltemp = \"Flame Thrower - Y\"; }\n        else if (_skill == 31) {skilltemp = \"Petal Blade\"; }\n        else if (_skill == 32) {skilltemp = \"Crunch\"; }\n        else if (_skill == 33) {skilltemp = \"Surprise\"; }\n        else if (_skill == 34) {skilltemp = \"Pressure Smash\"; }\n        else if (_skill == 35) {skilltemp = \"Take Down\"; }\n        else if (_skill == 36) {skilltemp = \"Sparkly Swirl\"; }\n        else if (_skill == 37) {skilltemp = \"Flame Thrower - Z\"; }\n        else if (_skill == 38) {skilltemp = \"Sing a Song\"; }\n        else if (_skill == 39) {skilltemp = \"Spirit Slash\"; }\n        else if (_skill == 40) {skilltemp = \"Aimshot\"; }\n        else if (_skill == 41) {skilltemp = \"Rainbow Force\"; }\n        else if (_skill == 42) {skilltemp = \"Dark Swipes\"; }\n        else if (_skill == 43) {skilltemp = \"Beat Up\"; }\n        else if (_skill == 44) {skilltemp = \"Mega Flare - X\"; }\n        else if (_skill == 45) {skilltemp = \"Toxic Bite\"; }\n        else if (_skill == 46) {skilltemp = \"Sonicboom\"; }\n        else if (_skill == 47) {skilltemp = \"Ancient Power\"; }\n        else if (_skill == 48) {skilltemp = \"Bee Missle\"; }\n        else if (_skill == 49) {skilltemp = \"Disaster\"; }\n        else if (_skill == 50) {skilltemp = \"Line Wind\"; }\n        else if (_skill == 51) {skilltemp = \"Crystal Lance\"; }\n        else if (_skill == 52) {skilltemp = \"Hydro Pressure\"; }\n        else if (_skill == 53) {skilltemp = \"Searing Blade\"; }\n        else if (_skill == 54) {skilltemp = \"Mega Flare - Z\"; }\n        else if (_skill == 55) {skilltemp = \"Explosive Smoke\"; }\n        else if (_skill == 56) {skilltemp = \"Air Strike\"; }\n        else if (_skill == 57) {skilltemp = \"Mega Flare - Y\"; }\n        else if (_skill == 58) {skilltemp = \"Shadow Cut\"; }\n        else if (_skill == 59) {skilltemp = \"Starfall\"; }\n        else if (_skill == 60) {skilltemp = \"Earth Shake\"; }\n        else if (_skill == 61) {skilltemp = \"Psycodamage\"; }\n        else if (_skill == 62) {skilltemp = \"Sunraze Slash\"; }\n        else if (_skill == 63) {skilltemp = \"Giga Blast\"; }\n        else {skilltemp = \"none\";}\n        skill = bytes(skilltemp);\n    }\n\n    function _getNameDescription(uint8 _species) private pure returns (string memory name, string memory description) {\n        //---\n        description = \"Experience the transformative Pet NFT in Fantom Adventure RPG, an immersive on-chain game. Watch it evolve through gameplay. Refresh the metadata for the latest status since it will evolve and bring it to explore the captivating world of Fantom Adventure RPG.\";\n        if        (_species==0) {\n            name = \"Mystery Box - X\";\n         } else if (_species==2) {\n            name = \"Mystery Box - Y\";\n        } else if (_species==3) {\n            name = \"Mystery Box - Z\";\n        } else if (_species==5) {\n            name = \"Youpling - X\";\n        } else if (_species==7) {\n            name = \"Youpling - Y\";\n        } else if (_species==8) {\n            name = \"Youpling - Z\";\n        } else if (_species==10) {\n            name = \"Youphorn - X\";\n \n        } else if (_species==16) {\n            name = \"Youphorn - Y\";\n \n        } else if (_species==17) {\n            name = \"Youphorn - Z\";\n \n        } else if (_species==23) {\n            name = \"Yougon - X\";\n \n        } else if (_species==30) {\n            name = \"Yougon - Y\";\n \n        } else if (_species==37) {\n            name = \"Yougon - Z\";\n \n        } else if (_species==44) {\n            name = \"Youking - X\";\n \n        } else if (_species==54) {\n            name = \"Youking - Z\";\n \n        } else if (_species==57) {\n            name = \"Youking - Y\";\n \n        }\n        //---  \n    }\n\n    function _getDayHrsMin(uint64 _time) private pure returns (string memory timeDHM) {\n        uint64 _day;\n        uint64 _hour;\n        uint64 _minute;\n        uint64 _temp;\n        _temp = _time;\n        _day = _temp / 86400; _temp = _temp - _day*86400;\n        _hour = _temp / 3600; _temp = _temp - _hour*3600;\n        _minute = _temp / 60;\n        timeDHM = string(abi.encodePacked(_toString(_day),\"d \",_toString(_hour),\"h \",_toString(_minute),\"m\"));\n    }\n   \n}\n"},"contracts/core.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8;\n \nimport \"./myPet.sol\";\nimport \"./evolution.sol\";\n\nlibrary core {\n    uint64 private constant FULL_ENDURANCE = 24 hours;\n    uint64 private constant INITIAL_STAMINA = 40 minutes;\n    uint64 private constant FULL_STAMINA = 40 minutes;\n    uint64 private constant INITIAL_ENDURANCE = 6 hours;\n    uint64 private constant lifeGainYouth = 365 days; \n    uint64 private constant YouthtoRookieTime = 10 seconds;\n\n\n\n    function _RandNumb(uint _rand, uint32 _maxRand, uint32 _offset) private pure returns (uint32) {\n        return uint32(_rand % (_maxRand+1-_offset) + _offset); // e.g. max 7, offset 2, means will get 2~7 randomly\n    }\n    \n    //--------------MATHS----------------- SATURATED--------\n    function sqrt32b(uint32 y) private pure returns (uint32 z) {\n        if (y > 3) {\n            z = y;\n            uint32 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n    function sub64b(uint64 a, uint64 b) private pure returns (uint64) {\n    uint64 c;\n        if (b <= a){\n        c = a - b;\n        } else {\n        c = 0;\n        }\n        return c;\n    }\n\n    function add64b(uint64 a, uint64 b) private pure returns (uint64) {\n        uint64 c; \n        unchecked {c= a + b;}\n        if (c < a){\n        c = 18446744073709551615;\n        }\n        return c;\n    }\n    function sub32b(uint32 a, uint32 b) private pure returns (uint32) {\n    uint32 c;\n        if (b <= a){\n        c = a - b;\n        } else {\n        c = 0;\n        }\n        return c;\n    }\n\n    function add32b(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c; \n        unchecked {c= a + b;}\n        if (c < a){\n        c = 4294967295;\n        }\n        return c;\n    }\n    function sub8b(uint8 a, uint8 b) private pure returns (uint8) {\n    uint8 c;\n        if (b <= a){\n        c = a - b;\n        } else {\n        c = 0;\n        }\n        return c;\n    }\n    function add8b(uint8 a, uint8 b) private pure returns (uint8) {\n        uint8 c; \n        unchecked {c= a + b;}\n        if (c < a){\n        c = 255;\n        }\n        return c;\n    }\n    function add9L(uint8 a, uint8 b) private pure returns (uint8) {\n        uint8 c; \n        unchecked {c= a + b;}\n        if (c < a || c>9){\n        c = 9;\n        }\n        return c;\n    }\n    function add16B999L(uint16 a, uint16 b) private pure returns (uint16) {\n        uint16 c; \n        unchecked {c= a + b;}\n        if (c < a || c>999){\n        c = 999;\n        }\n        return c;\n    }\n    function add32B999999L(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c; \n        unchecked {c= a + b;}\n        if (c < a || c>999999){\n        c = 999999;\n        }\n        return c;\n    }\n    //-----------------------------------------------------\n    /**\n    * @dev Mint a Pet egg based on a given random number.\n    * @param _deRand The random number used to generate the Pet.\n    * @return Pet The newly minted Pet.\n    */\n    function mintEgg(uint _deRand) external pure returns (A.Pets memory Pet) {\n        uint8 _randegg = uint8(_RandNumb(_deRand,2,0));\n        if (_randegg >0) {_randegg = _randegg + 1;}\n        //33% for each egg\n        Pet = A.Pets(\n            _randegg, // type of Pet species (egg 0 to 4)\n            10**_randegg, // gene\n            A.attributes(\n                uint8(_RandNumb((_deRand>>8)+(_deRand>>1),150,50)), // happiness\n                uint8(_RandNumb((_deRand>>16)+(_deRand>>1),150,50)), // discipline\n                0, // id (will be replaced in main function)\n                100, // weight\n                0 // stage\n            ),\n            A.powers(\n                1, // hitpoints\n                1, // strength\n                1, // agility\n                1 // intellegence\n            ),\n            0, // exp\n            A.timings(\n                0, // deadtime\n                0, // endurance\n                0, // outgoingtime\n                0, // stamina\n                0 // evolutiontime\n            ),\n            [0,0,0], // trait\n            [0,0,0], // skill\n            0, // status (0 = active)\n            uint16(_RandNumb((_deRand>>24)+(_deRand>>1),4,0)), // family\n            false // shinning (only for evolve, revive reset to false)\n        ); \n    }\n\n    function HatchEgg(A.Pets memory _Egg, address _ownerof) //due to story change in last minutes, change into BOX\n    external view returns(A.Pets memory Pet) {\n        Pet = _Egg;\n        require(msg.sender == _ownerof, \"xPermission\");\n        \n        require ((Pet.species <=4 ) \n                , \"xPetStatusVspecies\"); \n        A.powers memory _pwrs;\n        uint64 timenow = uint64(block.timestamp);\n        if      (Pet.species==4)   {_pwrs = A.powers(28000,76,26,26);}\n        else if (Pet.species==3)   {_pwrs = A.powers(47000,85,9,20);} \n        else if (Pet.species==2)   {_pwrs = A.powers(23000,65,38,24);} \n        else if (Pet.species==1)   {_pwrs = A.powers(26000,95,19,10);} \n        else   /*Pet.species==0*/  {_pwrs = A.powers(24000,68,18,40);} \n        Pet.species = Pet.species + 5;\n        Pet.attribute.stage = 1;\n        Pet.power = _pwrs;\n        Pet.time = A.timings (      timenow+lifeGainYouth, //deadtime\n                                        timenow+INITIAL_ENDURANCE, //endurance\n                                        0, //frozen time\n                                        timenow-INITIAL_STAMINA, //stamina\n                                        timenow+YouthtoRookieTime //evolutiontime\n                                    ); \n    }\n\n    function FeedPet(A.Pets memory _Pet, uint8 _foodtype,address _ownerof) \n    external view returns(A.Pets memory Pet) { //Foodtype 0 to 5\n        Pet = _Pet;\n        require (Pet.species >4  //not an egg\n                , \"xPetStatusVspecies\"); \n        require(msg.sender == _ownerof, \"xPermission\");\n        uint64 _timenow = uint64(block.timestamp);\n        uint64 _full;\n        uint32 _weight;\n        uint8 _happy;\n        if (Pet.time.endurance<_timenow) { //if Pet die of hunger but still has life time\n            Pet.time.endurance = _timenow; //revive from hunger then..\n        }\n        uint64 _enduranceleft = Pet.time.endurance-_timenow;\n        if (Pet.time.deadtime >= _timenow && Pet.time.endurance >= _timenow) { //Alive & Active\n            //Choose Your Food :p\n            if (_foodtype==6){_full = 9 hours; _weight = 9440; _happy = 10;}\n            else if (_foodtype==5){_full = 11 hours; _weight = 3135; _happy = 9;} \n            else if (_foodtype==4){_full = 7 hours; _weight = 1662; _happy = 6;} \n            else if (_foodtype==3){_full = 3 hours; _weight = 570; _happy = 3;} \n            else if (_foodtype==2){_full = 12 hours; _weight = 25200; _happy = 11;} \n            else if (_foodtype==1){_full = 8 hours; _weight = 12700; _happy = 8;} \n            else {_full = 4 hours; _weight = 5000; _happy = 5;} \n            //Eating\n            Pet.attribute.weight = add32b(Pet.attribute.weight,_weight);\n            Pet.time.endurance = add64b(Pet.time.endurance,_full);\n            if (Pet.time.endurance-_timenow > FULL_ENDURANCE){ //Your Pet has too full\n                Pet.time.endurance = _timenow+FULL_ENDURANCE; //cap at FULL_ENDURANCE\n                Pet.attribute.happiness = sub8b(Pet.attribute.happiness,1);\n            }else { // normal hours, :) happy\n                Pet.attribute.happiness = add8b(Pet.attribute.happiness,_happy);\n                //Pet.exp = Pet.exp + uint32(10*(_full));\n            }\n            Pet.exp = Pet.exp + 170*uint32((Pet.time.endurance-_timenow-_enduranceleft));\n        } \n        Pet = EVO.checkEvolve(Pet);\n    }\n\n    function trainPet(A.Pets memory _Pet, uint8 _traintype,address _ownerof) \n        external view returns(A.Pets memory Pet) { //TrainType 0 to 7\n        Pet = _Pet;\n        require (Pet.species >4  //not an egg\n                , \"xPetStatusVspecies\"); \n        require(msg.sender == _ownerof, \"xPermission\");\n        uint64 _timenow = uint64(block.timestamp);\n        //trait start first to prevent stack too deep, limitation of Solidity\n        if (Pet.time.deadtime > _timenow && Pet.time.endurance > _timenow //Pet still alive\n            && Pet.status == 0) { //Alive & Active\n            uint64 _stamina = sub64b(_timenow,Pet.time.stamina);\n            uint64 _tiredness;\n            uint32 _weightloss;\n            uint8 _happy;\n            uint8 _discipline;\n            \n            A.powers memory _pwrstemp;\n            //Choose Your training routing :p\n            if      (_traintype==13){_tiredness = 2 minutes; _weightloss = 600; _happy = 1; _discipline = 3; //reduce HAP, gain DIS\n                 _pwrstemp.hitpoints=4000; _pwrstemp.intellegence=30;}//Exercises\n            else if (_traintype==12){_tiredness = 2 minutes; _weightloss = 2100; _happy = 1; _discipline = 3; //reduce HAP, gain DIS\n                  _pwrstemp.strength=4; _pwrstemp.agility=30;}//Exercises\n            else if (_traintype==11){_tiredness = 2 minutes; _weightloss = 1520; _happy = 1; _discipline = 3; //reduce HAP, gain DIS\n                 _pwrstemp.strength=30; _pwrstemp.agility=2; _pwrstemp.intellegence=2;}//Exercises\n            else if (_traintype==10){_tiredness = 2 minutes; _weightloss = 1920; _happy = 1; _discipline = 3; //reduce HAP, gain DIS\n                 _pwrstemp.hitpoints=30000; _pwrstemp.strength=2; _pwrstemp.intellegence=2;}//Exercises\n            else if (_traintype==9){_tiredness = 0 minutes; _weightloss = 0; _happy = 0; _discipline = 0; //nothing\n                    }\n            else if (_traintype==8){_tiredness = 0 minutes; _weightloss = 0; _happy = 0; _discipline = 0; //nothing\n                    }\n            else if (_traintype==7){_tiredness = 25 minutes; _weightloss = 6251; _happy = 12; _discipline = 26; //reduce HAP, gain DIS\n                 _pwrstemp.hitpoints=145000; _pwrstemp.intellegence=280;}//Courses\n            else if (_traintype==6){_tiredness = 25 minutes; _weightloss = 23814; _happy = 12; _discipline = 25; //reduce HAP, gain DIS\n                  _pwrstemp.strength=100; _pwrstemp.agility=325;}//Running Machine\n            else if (_traintype==5){_tiredness = 25 minutes; _weightloss = 17320; _happy = 12; _discipline = 25; //reduce HAP, gain DIS\n                 _pwrstemp.strength=305; _pwrstemp.agility=55; _pwrstemp.intellegence=65;}//Wooden Dummy\n            else if (_traintype==4){_tiredness = 25 minutes; _weightloss = 11753; _happy = 13; _discipline = 25; //reduce HAP, gain DIS\n                  _pwrstemp.hitpoints=305000; _pwrstemp.strength=65; _pwrstemp.intellegence=55;}//sit under waterfall\n            else if (_traintype==3){_tiredness = 8 minutes; _weightloss = 2000; _happy = 2; _discipline = 10; //reduce HAP, gain DIS\n                 _pwrstemp.hitpoints=36000; _pwrstemp.intellegence=100;}//black board\n            else if (_traintype==2){_tiredness = 8 minutes; _weightloss = 7200; _happy = 2; _discipline = 9; //reduce HAP, gain DIS\n                  _pwrstemp.strength=26; _pwrstemp.agility=110;}//Sprint\n            else if (_traintype==1){_tiredness = 8 minutes; _weightloss = 5420; _happy = 2; _discipline = 9; //reduce HAP, gain DIS\n                 _pwrstemp.strength=115; _pwrstemp.agility=5; _pwrstemp.intellegence=16;}//Punching bag\n            else /*if (_traintype==0)*/{_tiredness = 8 minutes; _weightloss = 7600; _happy = 3; _discipline = 9; //reduce HAP, gain DIS\n                 _pwrstemp.hitpoints=116000; _pwrstemp.strength=10; _pwrstemp.intellegence=10;}//Push bolder\n            require(_stamina >= _tiredness, \"too tired\");\n            //traits affect\n            (_pwrstemp, _happy, _discipline) = traitAddStateTraining(_tiredness, Pet.trait,_pwrstemp, _happy, _discipline);\n\n            //training \n            Pet.power.hitpoints = add32B999999L(Pet.power.hitpoints,_pwrstemp.hitpoints );\n            Pet.power.strength = add16B999L(Pet.power.strength,_pwrstemp.strength );\n            Pet.power.agility = add16B999L(Pet.power.agility,_pwrstemp.agility );\n            Pet.power.intellegence = add16B999L(Pet.power.intellegence,_pwrstemp.intellegence );\n            Pet.attribute.happiness = sub8b(Pet.attribute.happiness,_happy);\n            Pet.attribute.discipline = add8b(Pet.attribute.discipline,_discipline);\n            Pet.attribute.weight = sub32b(Pet.attribute.weight,_weightloss);\n            if (Pet.attribute.weight == 0) {Pet.attribute.weight = 100;} //minimum weight\n            //EXP\n            Pet.exp = Pet.exp + 320000*uint32(_tiredness/1 minutes);\n            //=======capped by FULL STAMINA=======//\n            _stamina = sub64b(_stamina, _tiredness);\n            if ( _stamina > (FULL_STAMINA-_tiredness)) { \n                Pet.time.stamina = _timenow - FULL_STAMINA+_tiredness;\n            } else if (_stamina == 0) {//=0 in unsigned data = stamina go negative! TOO TIRED!\n                Pet.time.stamina = add64b(Pet.time.stamina,_tiredness);\n            } else {\n                Pet.time.stamina = add64b(Pet.time.stamina,_tiredness);\n            }\n            //============\n        }\n        Pet = EVO.checkEvolve(Pet);\n    }\n\n    function traitAddStateTraining(uint64 _tiredness, uint8[3] memory _traits, A.powers memory _pwrstemp, uint8 _happy, uint8 _discipline) \n    private pure returns(A.powers memory pwrstemp, uint8 happy, uint8 discipline){\n        pwrstemp = _pwrstemp;\n        happy = _happy;\n        discipline = _discipline;\n        uint16 _bonushr =  uint16(_tiredness/1 minutes); //tireness from Praise and Scold is 0, so Traits wont adds anything\n        for (uint256 i; i < 3; i++) {\n                if      (_traits[i] == 1) {pwrstemp.hitpoints = pwrstemp.hitpoints + 800*_bonushr;} //Tough\n                else if (_traits[i] == 2) {pwrstemp.strength= pwrstemp.strength +(8*_bonushr)/10;} //Brawler\n                else if (_traits[i] == 3) {pwrstemp.agility =pwrstemp.agility +(8*_bonushr)/10;} //Nimble\n                else if (_traits[i] == 4) {pwrstemp.intellegence = _pwrstemp.intellegence+(8*_bonushr)/10;} //Smart\n                //battletrait 5,6\n                else if (_traits[i] == 7) {happy = happy+(15*uint8(_bonushr))/10;} //Hardworking\n                else if (_traits[i] == 8) {discipline = discipline+(15*uint8(_bonushr))/10;} //Serious\n                //battletrait 9,10,11\n                else if (_traits[i] == 12) {pwrstemp.strength = pwrstemp.strength +(3*_bonushr)/10;} //Lonely\n                else if (_traits[i] == 13) {pwrstemp.strength = pwrstemp.strength +(4*_bonushr)/10;} //Bashful\n                else if (_traits[i] == 14) {pwrstemp.strength = pwrstemp.strength +(5*_bonushr)/10;} //Adamant\n                else if (_traits[i] == 15) {pwrstemp.strength = pwrstemp.strength +(6*_bonushr)/10;} //Naughty\n                else if (_traits[i] == 16) {pwrstemp.strength = pwrstemp.strength +(7*_bonushr)/10;} //Brave\n                else if (_traits[i] == 17) {pwrstemp.agility = pwrstemp.agility +(3*_bonushr)/10;} //Timid\n                else if (_traits[i] == 18) {pwrstemp.agility = pwrstemp.agility +(4*_bonushr)/10;} //Hasty\n                else if (_traits[i] == 19) {pwrstemp.agility = pwrstemp.agility +(5*_bonushr)/10;} //Jolly\n                else if (_traits[i] == 20) {pwrstemp.agility = pwrstemp.agility +(6*_bonushr)/10;} //Naive\n                else if (_traits[i] == 21) {pwrstemp.agility = pwrstemp.agility +(7*_bonushr)/10;} //Quirky\n                else if (_traits[i] == 22) {pwrstemp.intellegence = pwrstemp.intellegence +(3*_bonushr)/10;} //Mild\n                else if (_traits[i] == 23) {pwrstemp.intellegence = pwrstemp.intellegence +(4*_bonushr)/10;} //Quiet\n                else if (_traits[i] == 24) {pwrstemp.intellegence = pwrstemp.intellegence +(5*_bonushr)/10;} //Rash\n                else if (_traits[i] == 25) {pwrstemp.intellegence = pwrstemp.intellegence +(6*_bonushr)/10;} //Modest\n                else if (_traits[i] == 26) {pwrstemp.intellegence = pwrstemp.intellegence +(7*_bonushr)/10;} //Docile\n                else if (_traits[i] == 27) {pwrstemp.hitpoints = pwrstemp.hitpoints + 300*_bonushr;} //Relaxed\n                else if (_traits[i] == 28) {pwrstemp.hitpoints = pwrstemp.hitpoints + 400*_bonushr;} //Bold\n                else if (_traits[i] == 29) {pwrstemp.hitpoints = pwrstemp.hitpoints + 500*_bonushr;} //Impish\n                else if (_traits[i] == 30) {pwrstemp.hitpoints = pwrstemp.hitpoints + 600*_bonushr;} //Lax\n                else if (_traits[i] == 31) {pwrstemp.hitpoints = pwrstemp.hitpoints + 700*_bonushr;} //Careful\n            }\n    }\n\n    function battlingPet(uint8 rank, uint rand) external pure returns(A.Pets memory _BattlingPet) {\n        //rank 0 = stage1, 1= stage2, 2= stage3, 3=stage4 3->8->17->37\n        _BattlingPet.attribute.id = 10001;\n        _BattlingPet.attribute.stage = rank+1;\n        _BattlingPet.family = uint16(_RandNumb((rand>>4)+(rand>>1),4,0));\n        if (rank ==0 ) { \n            _BattlingPet.species = 8;\n            _BattlingPet.attribute.weight = _RandNumb((rand>>5)+(rand>>1),2500,1000);\n            _BattlingPet.power.hitpoints = _RandNumb((rand>>21)+(rand>>1),40000,10000);\n            _BattlingPet.power.strength = uint16(_RandNumb((rand>>41)+(rand>>1),50,40));\n            _BattlingPet.power.agility = uint16(_RandNumb((rand>>51)+(rand>>1),50,10));\n            _BattlingPet.power.intellegence = uint16(_RandNumb((rand>>61)+(rand>>1),50,10));\n        } else if (rank == 1) {\n            _BattlingPet.species = 17;\n            _BattlingPet.attribute.weight = _RandNumb((rand>>5)+(rand>>1),4500,1500);\n            _BattlingPet.power.hitpoints = _RandNumb((rand>>21)+(rand>>1),130000,5000);\n            _BattlingPet.power.strength = uint16(_RandNumb((rand>>41)+(rand>>1),130,95));\n            _BattlingPet.power.agility = uint16(_RandNumb((rand>>51)+(rand>>1),130,55));\n            _BattlingPet.power.intellegence = uint16(_RandNumb((rand>>61)+(rand>>1),130,55));\n            _BattlingPet.skill = [17,0,0];\n        } else if (rank == 2) {\n            _BattlingPet.species = 37; \n            _BattlingPet.attribute.weight = _RandNumb((rand>>5)+(rand>>1),17500,1500);\n            _BattlingPet.power.hitpoints = _RandNumb((rand>>21)+(rand>>1),420000,145000);\n            _BattlingPet.power.strength = uint16(_RandNumb((rand>>41)+(rand>>1),350,195));\n            _BattlingPet.power.agility = uint16(_RandNumb((rand>>51)+(rand>>1),350,155));\n            _BattlingPet.power.intellegence = uint16(_RandNumb((rand>>61)+(rand>>1),450,155));\n            _BattlingPet.skill = [17,37,0];    \n        } else /*if (rank == 3)*/{\n            _BattlingPet.species = 54;\n            _BattlingPet.attribute.weight = _RandNumb((rand>>5)+(rand>>1),25000,1500);\n            _BattlingPet.power.hitpoints = _RandNumb((rand>>21)+(rand>>1),800000,275000);\n            _BattlingPet.power.strength = uint16(_RandNumb((rand>>41)+(rand>>1),590,295));\n            _BattlingPet.power.agility = uint16(_RandNumb((rand>>51)+(rand>>1),590,275));\n            _BattlingPet.power.intellegence = uint16(_RandNumb((rand>>61)+(rand>>1),790,275));\n            _BattlingPet.skill = [17,37,54];   \n        }\n    }\n\n    function TowerPet(uint32 TowerLevel, uint _deRand) external pure returns(A.Pets memory _TowerPet, uint8[4] memory _chances, uint8 _nextTowerLevel) {\n        //rank 0 = stage1, 1= stage2, 2= stage3, 3=stage4\n        _TowerPet.attribute.id = 10001;\n        //TowerLevel 1~20 = level1, 10 level max. so stage 1 to 4, 2.5 stage each.\n        //Towerlevel/41 = stage, max TowerLevel 200, = stage 4 (rounded)\n        //e.g. level 1 and 2 = stage 1, \n        _TowerPet.attribute.stage = uint8(((TowerLevel*10)+801)/601); //stage: 1 1 2 2 2 3 3 3 4 4 \n        _TowerPet.family = uint8(TowerLevel%5); //0 to 4\n        /* chances for 30 Artifact according to rarity\n        stage   ratio   15  9   6   30\n        1       1       8   1   0   \n        2       1       7   2   0   \n        3       1       6   2   1   \n        4       1       6   2   1   \n        5       1       5   3   1   \n        6       0       5   4   1   \n        7       0       4   4   2   \n        8       0       1   6   3   \n        9       0       0   5   5   \n        sum\t\t        42\t29\t24\t95\n\t    ratio\t       13.2 9.1 7.5\t common chances is low by assuming most people cant reach level 10\n        */\n        if (TowerLevel <= 20 ) { //level1 stage 1\n            _TowerPet.species = 5;\n            _TowerPet.power.hitpoints = 15000+TowerLevel*700;\n            _TowerPet.power.strength = uint16(10+((TowerLevel*75)%50));\n            _TowerPet.power.agility = uint16(10+((TowerLevel*88)%50));\n            _TowerPet.power.intellegence = uint16(10+((TowerLevel*33)%50));\n            _chances = [1,8,1,0];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,60,41)); //intentionally skip\n        } else if (TowerLevel <= 40 ) { //level2 stage 1\n            _TowerPet.species = 7;\n            _TowerPet.power.hitpoints = 18000+((TowerLevel*900)%18000);\n            _TowerPet.power.strength = uint16(30+((TowerLevel*75)%50));\n            _TowerPet.power.agility = uint16(30+((TowerLevel*88)%50));\n            _TowerPet.power.intellegence = uint16(30+((TowerLevel*33)%50));\n            _chances = [1,7,2,0];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,80,41));\n        } else if (TowerLevel <= 60 ) { //level3 stage 2\n            _TowerPet.species = 10;\n            _TowerPet.power.hitpoints = 35000+((TowerLevel*1900)%30000);\n            _TowerPet.power.strength = uint16(70+((TowerLevel*75)%70));\n            _TowerPet.power.agility = uint16(70+((TowerLevel*88)%70));\n            _TowerPet.power.intellegence = uint16(70+((TowerLevel*33)%70));\n            _TowerPet.skill = [10,0,0]; \n            _chances = [1,6,2,1];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,100,81)); //skip\n        } else if (TowerLevel <= 80 ) { //level4 stage 2\n            _TowerPet.species = 16;\n            _TowerPet.power.hitpoints = 70000+((TowerLevel*1900)%70000);\n            _TowerPet.power.strength = uint16(100+((TowerLevel*75)%100));\n            _TowerPet.power.agility = uint16(100+((TowerLevel*88)%100));\n            _TowerPet.power.intellegence = uint16(120+((TowerLevel*33)%120));\n            _TowerPet.skill = [16,0,0]; \n            _chances = [1,6,2,1];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,120,81));\n        } else if (TowerLevel <= 100 ) { //level5 stage 2\n            _TowerPet.species = 17;\n            _TowerPet.power.hitpoints = 100000+((TowerLevel*1900)%70000);\n            _TowerPet.power.strength = uint16(150+((TowerLevel*75)%100));\n            _TowerPet.power.agility = uint16(150+((TowerLevel*88)%100));\n            _TowerPet.power.intellegence = uint16(180+((TowerLevel*33)%120));\n            _TowerPet.skill = [17,0,0]; \n            _chances = [1,5,3,1];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,140,121));\n        } else if (TowerLevel <= 120 ) { //level6 stage 3\n            _TowerPet.species = 23;\n            _TowerPet.power.hitpoints = 250000+((TowerLevel*1900)%130000);\n            _TowerPet.power.strength = uint16(220+((TowerLevel*75)%100));\n            _TowerPet.power.agility = uint16(220+((TowerLevel*88)%100));\n            _TowerPet.power.intellegence = uint16(350+((TowerLevel*33)%120));\n            _TowerPet.skill = [10,23,0]; \n            _chances = [0,5,4,1];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,160,121));\n        } else if (TowerLevel <= 140 ) { //level7 stage 3\n            _TowerPet.species = 30;\n            _TowerPet.power.hitpoints = 350000+((TowerLevel*1900)%170000);\n            _TowerPet.power.strength = uint16(350+((TowerLevel*75)%100));\n            _TowerPet.power.agility = uint16(350+((TowerLevel*88)%100));\n            _TowerPet.power.intellegence = uint16(550+((TowerLevel*33)%120));\n            _TowerPet.skill = [16,30,0];\n            _chances = [0,4,4,2]; \n            _nextTowerLevel = uint8(_RandNumb(_deRand,180,161));\n        } else if (TowerLevel <= 160 ) { //level8 stage 3\n            _TowerPet.species = 37;\n            _TowerPet.power.hitpoints = 450000+((TowerLevel*1900)%270000);\n            _TowerPet.power.strength = uint16(450+((TowerLevel*75)%150));\n            _TowerPet.power.agility = uint16(450+((TowerLevel*88)%150));\n            _TowerPet.power.intellegence = uint16(660+((TowerLevel*33)%120));\n            _TowerPet.skill = [17,37,0]; \n            _chances = [0,1,6,3];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,200,161));\n        } else if (TowerLevel <= 180 ) { //level9 stage 4\n            _TowerPet.species = 44;\n            _TowerPet.power.hitpoints = 600000+((TowerLevel*1900)%300000);\n            _TowerPet.power.strength = uint16(600+((TowerLevel*75)%150));\n            _TowerPet.power.agility = uint16(600+((TowerLevel*88)%150));\n            _TowerPet.power.intellegence = uint16(730+((TowerLevel*33)%120));\n            _TowerPet.skill = [10,23,44]; \n            _chances = [0,0,5,5];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,200,181));\n        } else if (TowerLevel <= 200 ) { //level10 stage 4\n            _TowerPet.species = 54;\n            _TowerPet.power.hitpoints = 900000+((TowerLevel*1900)%100000);\n            _TowerPet.power.strength = uint16(900+((TowerLevel*75)%100));\n            _TowerPet.power.agility = uint16(900+((TowerLevel*88)%100));\n            _TowerPet.power.intellegence = uint16(900+((TowerLevel*33)%100));\n            _TowerPet.skill = [17,37,54]; \n            _chances = [0,0,0,10];\n            _nextTowerLevel = uint8(_RandNumb(_deRand,20,1));\n        }\n    }\n\n    function battlePet(uint _deRand, A.Pets memory _Pet1, A.Pets memory _Pet2) \n    //check owner at main, because simulation need permissionless\n    external pure returns(bool Mon1Win, uint BattleRhythm, uint8 bit, uint64 OppoDamage) { \n        //---- The BattleRythm is 256 bits encoded 85 actions(3bits [1bit attacker, 2bits skill]), \n        // ---- so the battle ended after 85 turns or either one has 0 HP---------------- \n        //whoever has more HP left win, if same HP, Pet2 win. NO DRAW -----------//\n        uint32 damage;\n        uint32 effort;\n        uint32 actionpoints1 = _Pet2.power.agility; //reverse, Pet2 slow, means Pet1 attack more times\n        uint32 actionpoints2 = _Pet1.power.agility;\n        uint8 weakness; //0 = nothing, 1 = more damage on Pet1, 2= more daamge on Pet2\n                //0 = Red, 1=Yellow, 2=Green, 3=Blue, 4=Purple\n        //Yellow==Purple==Red==Green==Blue\n        //1.2x against\n\t    //Blue==Yellow==Green==Purple==Red\n        if ( (_Pet1.family == 3 && _Pet2.family == 1) //Blue weaks against Yellow\n           ||(_Pet1.family == 1 && _Pet2.family == 4) //Yellow weaks against Purple\n           ||(_Pet1.family == 2 && _Pet2.family == 0) //Green weaks against Red\n           ||(_Pet1.family == 4 && _Pet2.family == 2) //Purple weaks against Green\n           ||(_Pet1.family == 0 && _Pet2.family == 3) //Red weaks against Blue\n        ) \n        {weakness = 1;}\n        //---\n        if ( (_Pet2.family == 3 && _Pet1.family == 1) //Blue weaks against Yellow\n           ||(_Pet2.family == 1 && _Pet1.family == 4) //Yellow weaks against Purple\n           ||(_Pet2.family == 2 && _Pet1.family == 0) //Green weaks against Red\n           ||(_Pet2.family == 4 && _Pet1.family == 2) //Purple weaks against Green\n           ||(_Pet2.family == 0 && _Pet1.family == 3) //Red weaks against Blue\n        ) \n        {weakness = 2;}\n        // because who has less actionpoints move next\n        //while<= 253 bit 1round 3 bit 15 rounds, means 45 bit\n        while (bit<=253 && _Pet1.power.hitpoints > 0 && _Pet2.power.hitpoints > 0 ){\n            if (actionpoints1 <= actionpoints2) { //Pet1 move\n                bit++; //bit ++ first, means set '0'\n                _deRand = (_deRand>>3)+(_deRand>>1);\n                (BattleRhythm,effort,damage)=_chooseSkill(_deRand,_Pet1,BattleRhythm,bit);\n                bit=bit+2; //2bits has set in the function above for skill.\n                actionpoints1 = actionpoints1 + effort +  _Pet2.power.agility; // purposely reverse Pet2 agi to action 1\n                if (weakness == 2) {damage = damage*2;}\n                _Pet2.power.hitpoints = sub32b(_Pet2.power.hitpoints,damage);\n                OppoDamage += damage;\n            } else { //Pet2 move\n                BattleRhythm = BattleRhythm + 2**bit; //encode who attack, 1 = Pet2 attack\n                bit++; //bit++ before set, means set '1'\n                _deRand = (_deRand>>3)+(_deRand>>1);\n                (BattleRhythm,effort,damage)=_chooseSkill(_deRand,_Pet2,BattleRhythm,bit);\n                bit=bit+2; //2bits has set in the function above.\n                actionpoints2 = actionpoints2 + effort +  _Pet1.power.agility; // purposely reverse Pet1 agi to action 2\n                if (weakness == 1) {damage = damage*2;}\n                _Pet1.power.hitpoints = sub32b(_Pet1.power.hitpoints,damage);\n            }\n        }\n        if (_Pet1.power.hitpoints >= _Pet2.power.hitpoints) {Mon1Win = true;} else {Mon1Win = false;}\n        \n    }\n    function _chooseSkill(uint _deRand, A.Pets memory _Pet, uint _BattleRhythm, uint8 _bit)\n    private pure returns( uint BattleRhythm, uint32 effort, uint32 damage) {\n        uint8 skill;\n        BattleRhythm = _BattleRhythm;\n        if (_RandNumb(_deRand,1300,1) <= 301+uint16(_Pet.power.intellegence)) { //use skills based 23% chances\n            skill = uint8(_RandNumb((_deRand>>3)+(_deRand>>1),2,0)); //translate to skill array 0 1 2\n            //skill == 0 means no need to set anything on skill (00)\n            if (skill == 1) {BattleRhythm = BattleRhythm + 2**_bit;} //binary 00 (01) 10, set LSB\n            _bit++;\n            if (skill == 2) {BattleRhythm = BattleRhythm + 2**_bit;} //binary 00 01 (10), set MSB\n            //no need _bit++ as _bit won't return\n            (damage,effort) = _SkillsState(_Pet.power,_Pet.attribute, _Pet.skill[skill]);\n        } else {//normal attack, also encoded as skill array (11), Skill[3] always normal attack\n            BattleRhythm = BattleRhythm + 2**_bit;\n            _bit++;\n            BattleRhythm = BattleRhythm + 2**_bit;\n            damage = _Pet.power.strength;\n            damage = damage * 50;\n            effort = 100;\n        } \n        \n    }\n    function _SkillsState(A.powers memory _powers, A.attributes memory _attributes, uint8 SkillNumber)\n    private pure returns(uint32 damage, uint32 effort) {\n        // you won't get a skill before Stage 2\n        uint64 HP = _powers.hitpoints;\n        uint32 STR = _powers.strength;\n        uint32 AGI = _powers.agility;\n        uint32 INT = _powers.intellegence;\n        uint32 HAPPINESS = _attributes.happiness;\n        uint32 DISCIPLINE = _attributes.discipline;\n        if (SkillNumber == 0) {damage=STR*50; effort = 100;}\n        else if (SkillNumber == 10) {damage= 50*STR + 35*AGI ; effort = 160;}   ///------- use this\n        else if (SkillNumber == 11) {damage= 85*STR + 15*INT ; effort = 155;}\n        else if (SkillNumber == 12) {damage= 115*STR ; effort = 200;}\n        else if (SkillNumber == 13) {damage= 30*STR + 30*AGI + 30*INT ; effort = 150;}\n        else if (SkillNumber == 14) {damage= 105*STR ; effort = 190;}\n        else if (SkillNumber == 15) {damage= 40*STR + 63*AGI ; effort = 160;}\n        else if (SkillNumber == 16) {damage= 40*STR + 60*AGI ; effort = 170;}   ///------- use this\n        else if (SkillNumber == 17) {damage= 80*STR + 35*INT ; effort = 195;}   ///------- use this\n        else if (SkillNumber == 18) {damage= 90*STR + 40*INT ; effort = 220;}\n        else if (SkillNumber == 19) {damage= 50*STR + 100*INT ; effort = 230;}\n        else if (SkillNumber == 20) {damage= 150*STR ; effort = 230;}\n        else if (SkillNumber == 21) {damage= 50*STR + 100*AGI ; effort = 230;}\n        else if (SkillNumber == 22) {damage= 50*STR + 50*AGI + 50*INT ; effort = 230;}\n        else if (SkillNumber == 23) {damage= 75*STR + 125*AGI ; effort = 265;}   ///------- use this\n        else if (SkillNumber == 24) {damage= 135*STR + 75*AGI ; effort = 270;}\n        else if (SkillNumber == 25) {damage= 200*AGI ; effort = 266;}\n        else if (SkillNumber == 26) {damage= uint32((14*HP)/100) + 125*STR ; effort = 287;}\n        else if (SkillNumber == 27) {damage= 90*STR + 90*AGI + 90*INT ; effort = 330;}\n        else if (SkillNumber == 28) {damage= 225*STR ; effort = 290;}\n        else if (SkillNumber == 29) {damage= 50*STR + 125*AGI ; effort = 258;}\n        else if (SkillNumber == 30) {damage= 90*STR + 110*AGI ; effort = 277;}   ///------- use this\n        else if (SkillNumber == 31) {damage= 150*STR + 50*AGI ; effort = 302;}\n        else if (SkillNumber == 32) {damage= 165*STR + 175*DISCIPLINE ; effort = 298;}\n        else if (SkillNumber == 33) {damage= 185*INT ; effort = 244;}\n        else if (SkillNumber == 34) {damage= 55*STR + 140*INT ; effort = 280;}\n        else if (SkillNumber == 35) {damage= 250*STR ; effort = 295;}\n        else if (SkillNumber == 36) {damage= 210*STR ; effort = 300;}\n        else if (SkillNumber == 37) {damage= uint32((15*HP)/100) + 125*STR ; effort = 310;}   ///------- use this\n        else if (SkillNumber == 38) {damage= 125*STR + 40*AGI + 40*INT ; effort = 275;}\n        else if (SkillNumber == 39) {damage= 185*STR + 50*AGI ; effort = 295;}\n        else if (SkillNumber == 40) {damage= 158*STR + 50*AGI + 25*INT ; effort = 287;}\n        else if (SkillNumber == 41) {damage= 160*STR + 50*INT + 175*HAPPINESS ; effort = 320;}\n        else if (SkillNumber == 42) {damage= 160*STR +50*INT + 175*DISCIPLINE ; effort = 315;}\n        else if (SkillNumber == 43) {damage= 185*STR + 100*AGI ; effort = 380;}\n        else if (SkillNumber == 44) {damage= 170*STR + 170*INT ; effort = 395;}   ///------- use this\n        else if (SkillNumber == 45) {damage= uint32((25*HP)/100) + 100*STR ; effort = 376;}\n        else if (SkillNumber == 46) {damage= 150*STR + 150*INT ; effort = 380;}\n        else if (SkillNumber == 47) {damage= 325*STR ; effort = 400;}\n        else if (SkillNumber == 48) {damage= 150*STR + 125*AGI + 50*INT ; effort = 375;}\n        else if (SkillNumber == 49) {damage= 125*STR + 125*AGI + 125*INT ; effort = 450;}\n        else if (SkillNumber == 50) {damage= 175*AGI + 100*INT + 200*HAPPINESS ; effort = 380;}\n        else if (SkillNumber == 51) {damage= 75*STR + 200*INT + 250*DISCIPLINE ; effort = 385;}\n        else if (SkillNumber == 52) {damage= 150*STR + 125*AGI + 175*HAPPINESS ; effort = 370;}\n        else if (SkillNumber == 53) {damage= 175*STR + 700*DISCIPLINE ; effort = 395;}\n        else if (SkillNumber == 54) {damage= 200*STR + 150*INT ; effort = 450;}   ///------- use this\n        else if (SkillNumber == 55) {damage= 115*STR + 115*AGI + 115*INT ; effort = 400;}\n        else if (SkillNumber == 56) {damage= 150*STR + 150*INT ; effort = 375;}\n        else if (SkillNumber == 57) {damage= 125*STR + 100*STR + 100*INT ; effort = 360;}   ///------- use this\n        else if (SkillNumber == 58) {damage= 60*STR + 75*INT + 750*HAPPINESS ; effort = 380;}\n        else if (SkillNumber == 59) {damage= 345*INT ; effort = 400;}\n        else if (SkillNumber == 60) {damage= 225*STR + 85*AGI ; effort = 360;}\n        else if (SkillNumber == 61) {damage= 160*STR + 160*INT ; effort = 380;}\n        else if (SkillNumber == 62) {damage= 125*STR + 200*INT ; effort = 385;}\n        else if (SkillNumber == 63) {damage= 125*STR + 125*AGI + 125*INT ; effort = 400;}\n    }\n\n    function battlewinlosereward(A.Pets memory _Pet, bool _win, uint8 _rank) external view \n    returns (A.Pets memory Pet){\n        Pet = _Pet;\n        uint32 _exp;\n        A.powers memory _pwrstemp;\n        uint8 _happy;\n        uint8 _discipline;\n        uint32 _weight;\n        if ( _rank >= 4 ) { //means not fight training\n            if (_win == true) { // if won\n            \n                _exp = 1620000;\n                _pwrstemp.hitpoints =15000;\n                _pwrstemp.strength =15;\n                _pwrstemp.agility =15;\n                _pwrstemp.intellegence =15;\n                Pet.attribute.happiness = add8b(Pet.attribute.happiness,10);\n                _discipline =5;\n                _weight =3815;\n                \n            } else { //lose...\n                _exp = 950000;\n                _pwrstemp.hitpoints =6000;\n                _pwrstemp.strength =6;\n                _pwrstemp.agility =6;\n                _pwrstemp.intellegence =6;\n                Pet.attribute.happiness = sub8b(Pet.attribute.happiness,10);\n                _discipline =5;\n                _weight =3815;\n            }\n            (_pwrstemp, _happy, _discipline) = traitAddStateBattle(2 minutes, Pet.trait,_pwrstemp, _happy, _discipline);\n        \n            Pet.exp = add32b(Pet.exp,_exp); \n            Pet.power.hitpoints = add32B999999L(Pet.power.hitpoints,_pwrstemp.hitpoints);\n            Pet.power.strength = add16B999L(Pet.power.strength,_pwrstemp.strength);\n            Pet.power.agility = add16B999L(Pet.power.agility,_pwrstemp.agility);\n            Pet.power.intellegence = add16B999L(Pet.power.intellegence,_pwrstemp.intellegence);\n            Pet.attribute.happiness = add8b(Pet.attribute.happiness,_happy);\n            Pet.attribute.discipline = add8b(Pet.attribute.discipline,_discipline);\n            Pet.attribute.weight = sub32b(Pet.attribute.weight,_weight);\n        }\n        Pet = EVO.checkEvolve(Pet);\n    }\n\n    function traitAddStateBattle(uint64 _tiredness, uint8[3] memory _traits, A.powers memory _pwrstemp, uint8 _happy, uint8 _discipline) \n    private pure returns(A.powers memory pwrstemp, uint8 happy, uint8 discipline){\n        pwrstemp = _pwrstemp;\n        happy = _happy;\n        discipline = _discipline;\n        uint16 _bonushr =  uint16(_tiredness/1 minutes);\n        for (uint256 i; i < 3; i++) {\n                //training trait 1 to 4\n                if      (_traits[i] == 5) { pwrstemp.hitpoints = pwrstemp.hitpoints + 100; //Pride\n                                            pwrstemp.strength= pwrstemp.strength + 2;\n                                            pwrstemp.agility = pwrstemp.agility + 2;\n                                            pwrstemp.intellegence = pwrstemp.intellegence + 2;\n                                        } \n                else if (_traits[i] == 6) { pwrstemp.hitpoints = pwrstemp.hitpoints + 1000; //Resilient\n                                            pwrstemp.strength= pwrstemp.strength + 1;\n                                            pwrstemp.agility = pwrstemp.agility + 1;\n                                            pwrstemp.intellegence = pwrstemp.intellegence + 1;\n                                        }  \n                else if (_traits[i] == 7) {happy = happy+(15*uint8(_bonushr))/10;} //Hardworking\n                else if (_traits[i] == 8) {discipline = discipline+(15*uint8(_bonushr))/10;} //Serious\n                \n                else if (_traits[i] == 9) {pwrstemp.intellegence = pwrstemp.intellegence +_bonushr;} //Creative\n                else if (_traits[i] == 10) {pwrstemp.strength = pwrstemp.strength +_bonushr;} //Ambitious\n                else if (_traits[i] == 11) {pwrstemp.agility = pwrstemp.agility +_bonushr;} //Multitasking\n\n                else if (_traits[i] == 12) {pwrstemp.strength = pwrstemp.strength +(3*_bonushr)/10;} //Lonely\n                else if (_traits[i] == 13) {pwrstemp.strength = pwrstemp.strength +(4*_bonushr)/10;} //Bashful\n                else if (_traits[i] == 14) {pwrstemp.strength = pwrstemp.strength +(5*_bonushr)/10;} //Adamant\n                else if (_traits[i] == 15) {pwrstemp.strength = pwrstemp.strength +(6*_bonushr)/10;} //Naughty\n                else if (_traits[i] == 16) {pwrstemp.strength = pwrstemp.strength +(7*_bonushr)/10;} //Brave\n                else if (_traits[i] == 17) {pwrstemp.agility = pwrstemp.agility +(3*_bonushr)/10;} //Timid\n                else if (_traits[i] == 18) {pwrstemp.agility = pwrstemp.agility +(4*_bonushr)/10;} //Hasty\n                else if (_traits[i] == 19) {pwrstemp.agility = pwrstemp.agility +(5*_bonushr)/10;} //Jolly\n                else if (_traits[i] == 20) {pwrstemp.agility = pwrstemp.agility +(6*_bonushr)/10;} //Naive\n                else if (_traits[i] == 21) {pwrstemp.agility = pwrstemp.agility +(7*_bonushr)/10;} //Quirky\n                else if (_traits[i] == 22) {pwrstemp.intellegence = pwrstemp.intellegence +(3*_bonushr)/10;} //Mild\n                else if (_traits[i] == 23) {pwrstemp.intellegence = pwrstemp.intellegence +(4*_bonushr)/10;} //Quiet\n                else if (_traits[i] == 24) {pwrstemp.intellegence = pwrstemp.intellegence +(5*_bonushr)/10;} //Rash\n                else if (_traits[i] == 25) {pwrstemp.intellegence = pwrstemp.intellegence +(6*_bonushr)/10;} //Modest\n                else if (_traits[i] == 26) {pwrstemp.intellegence = pwrstemp.intellegence +(7*_bonushr)/10;} //Docile\n                else if (_traits[i] == 27) {pwrstemp.hitpoints = pwrstemp.hitpoints + 300*_bonushr;} //Relaxed\n                else if (_traits[i] == 28) {pwrstemp.hitpoints = pwrstemp.hitpoints + 400*_bonushr;} //Bold\n                else if (_traits[i] == 29) {pwrstemp.hitpoints = pwrstemp.hitpoints + 500*_bonushr;} //Impish\n                else if (_traits[i] == 30) {pwrstemp.hitpoints = pwrstemp.hitpoints + 600*_bonushr;} //Lax\n                else if (_traits[i] == 31) {pwrstemp.hitpoints = pwrstemp.hitpoints + 700*_bonushr;} //Careful\n            }\n    }\n\n\n}\n\n\n\n\n"},"contracts/myPet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary A {\n\n    // A struct to hold the attributes of a Pet\n    struct attributes {\n        uint8 happiness;   // The happiness level of the Pet (max 255)\n        uint8 discipline;  // The discipline level of the Pet (max 255)\n        uint16 id;         // The unique ID of the Pet, used to track the same token\n        uint32 weight;     // The weight of the Pet in grams\n        uint8 stage;       // The stage of the Pet's life cycle (0:Egg, 1:Youth, 2:Rookie, 3:Mature, 4:Perfect)\n    }\n\n    // A struct to hold the powers of a Pet\n    struct powers {\n        uint32 hitpoints;     // The ability of the Pet to take damage (max limit 9,999)\n        uint16 strength;      // The strength of the Pet, affecting damage (max limit 999)\n        uint16 agility;       // The agility of the Pet, affecting turns (max limit 999)\n        uint16 intellegence;  // The intelligence of the Pet, affecting skill chances (max limit 999)\n    }\n\n    // A struct to hold the timings of a Pet\n    struct timings {\n        uint64 deadtime;       // The life cycle of the Pet\n        uint64 endurance;      // The hunger/food level of the Pet\n        uint64 frozentime;     // The time the Pet is frozen during an adventure\n        uint64 stamina;        // The limit of activities the Pet can perform\n        uint64 evolutiontime;  // The time when the Pet attempts to evolve\n    }\n\n    // A struct to hold the Pet's data\n    struct Pets {\n        uint8 species;       // The type of Pet\n        uint256 gene;        // Each digit represents a type of Pet that has ever evolved\n        attributes attribute;\n        powers power;\n        uint32 exp;          // The experience points gained from battles/evolutions, impacting evolution\n        timings time;\n        uint8[3] trait;      // The traits gained at every evolution\n        uint8[3] skill;      // The skills gained at every evolution\n        uint32 status;       // The status of the Pet\n        uint16 family;       // The family of the Pet\n        bool shinning;       // The shinning state of the Pet\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"@openzeppelin/contracts@4.7.0/token/ERC721/extensions/ERC721Burnable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/token/ERC721/extensions/ERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/token/ERC721/ERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"},"contracts/evolution.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./myPet.sol\";\nlibrary EVO {\n    //---------CONSTANT -----------------------------\n    uint64 private constant lifeGainRookie = 365 days; \n    uint64 private constant lifeGainMature = 365 days; \n    uint64 private constant lifeGainPerfect = 365 days; \n    //evolution requirement from\n    uint64 private constant RookietoMatureTime = 10 seconds; \n    uint64 private constant MaturetoPerfectTime = 10 seconds; \n    uint64 private constant PerfecttoUnknownTime = 365 days; \n    //--------------- private functions----------------\n\n    function _RandNumb(uint _rand, uint32 _maxRand, uint32 _offset) private pure returns (uint32) {\n        return uint32(_rand % (_maxRand-_offset) + _offset);\n    }\n    \n    //--------------MATHS----------------- SATURATED--------\n    function sqrt32b(uint32 y) private pure returns (uint32 z) {\n        if (y > 3) {\n            z = y;\n            uint32 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n    function sub64b(uint64 a, uint64 b) private pure returns (uint64) {\n    uint64 c;\n        if (b <= a){\n        c = a - b;\n        } else {\n        c = 0;\n        }\n        return c;\n    }\n\n    function add64b(uint64 a, uint64 b) private pure returns (uint64) {\n        uint64 c; \n        unchecked {c= a + b;}\n        if (c < a){\n        c = 18446744073709551615;\n        }\n        return c;\n    }\n    function sub32b(uint32 a, uint32 b) private pure returns (uint32) {\n    uint32 c;\n        if (b <= a){\n        c = a - b;\n        } else {\n        c = 0;\n        }\n        return c;\n    }\n\n    function add32b(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c; \n        unchecked {c= a + b;}\n        if (c < a){\n        c = 4294967295;\n        }\n        return c;\n    }\n    function sub8b(uint8 a, uint8 b) private pure returns (uint8) {\n    uint8 c;\n        if (b <= a){\n        c = a - b;\n        } else {\n        c = 0;\n        }\n        return c;\n    }\n    function add8b(uint8 a, uint8 b) private pure returns (uint8) {\n        uint8 c; \n        unchecked {c= a + b;}\n        if (c < a){\n        c = 255;\n        }\n        return c;\n    }\n    function add9L(uint8 a, uint8 b) private pure returns (uint8) {\n        uint8 c; \n        unchecked {c= a + b;}\n        if (c < a || c>9){\n        c = 9;\n        }\n        return c;\n    }\n    function add16B999L(uint16 a, uint16 b) private pure returns (uint16) {\n        uint16 c; \n        unchecked {c= a + b;}\n        if (c < a || c>999){\n        c = 999;\n        }\n        return c;\n    }\n    function add32B999999L(uint32 a, uint32 b) private pure returns (uint32) {\n        uint32 c; \n        unchecked {c= a + b;}\n        if (c < a || c>999999){\n        c = 999999;\n        }\n        return c;\n    }\n    //-----------------------------------------------------\n    function _returnLevel(uint32 _exp) private pure returns (uint32 _level){\n        _level= sqrt32b(_exp)/258 + 1; //min level 1 - max level 255\n        \n    }\n\n    function _getGene(uint256 _gene, uint8 _order) private pure returns (uint8) { \n        //order position count from 1 from LSB\n        //e.g. gene 1335745, order 2, returns 4 \n        return uint8((_gene/10**(_order-1)) - (_gene / 10**(_order))*10);\n    }\n    function _setGene(uint256 _gene, uint8 _order, uint8 _setNum) private pure returns (uint256 gene) { \n        //order position count from 1 from LSB\n        //e.g. gene 1335745, order 2, setNum 9 returns 1335795\n        \n        uint x = _gene - (_gene/(10**(_order-1))*(10**(_order-1))); //xxX45\n        uint y = (_gene/(10**(_order))*(10**(_order))); //123Xxx\n        gene = _setNum*10**(_order-1) + x + y;    \n    }\n\n    function _ShinningGive(uint _rand, uint32 _exp) private pure returns (bool){\n        if( _RandNumb(_rand,255,0)<= _returnLevel(_exp) ){return true;} else {return false;}\n    }\n//-------------------------------------------------------------------------------\n//-----------EXTERNAL ------------v\n\n    function checkEvolve(A.Pets memory _Pet) external view returns (A.Pets memory){\n        uint64 timenow= uint64(block.timestamp);\n        //evolved to rookie lvl 14, to mature lvl18, to perfect lvl 20\n        uint8 species = _Pet.species;\n        if (_Pet.attribute.stage == 1 && (_returnLevel(_Pet.exp) >= 14) && _Pet.time.evolutiontime < timenow) { //youth to rookie and reach level 14\n            if        (species == 5){\n                (_Pet,) = _EvolveID10RQ(1,_Pet);\n  //          } else if (species == 6) {\n  //              (_Pet,) = _EvolveID14RQ(1,_Pet);  //Cut feature due to timeline for Hackathon\n            } else if (species == 7) {\n                (_Pet,) = _EvolveID16RQ(1,_Pet);\n            } else if (species == 8) {\n                (_Pet,) = _EvolveID17RQ(1,_Pet);\n    //        } else if (species == 9) {\n    //            (_Pet,) = _EvolveID19RQ(1,_Pet);\n            }\n            \n        } else if (_Pet.attribute.stage == 2 && (_returnLevel(_Pet.exp) >= 18) && _Pet.time.evolutiontime < timenow) { //rookie to mature and reach level 18\n            if        (species == 10){ //link to above\n                (_Pet,) = _EvolveID23RQ(1,_Pet);\n    //        } else if (species == 14) {\n    //            (_Pet,) = _EvolveID32RQ(1,_Pet); //Cut feature due to timeline for Hackathon\n            } else if (species == 16) {\n                (_Pet,) = _EvolveID30RQ(1,_Pet);\n            } else if (species == 17) {\n                (_Pet,) = _EvolveID37RQ(1,_Pet);\n    //        } else if (species == 19) {\n    //            (_Pet,) = _EvolveID27RQ(1,_Pet);\n            }\n            \n        } else if (_Pet.attribute.stage == 3 && (_returnLevel(_Pet.exp) >= 20) && _Pet.time.evolutiontime < timenow) { //mature to perfect and reach level 20\n            if        (species == 23){ //link to above\n                (_Pet,) = _EvolveID44RQ(1,_Pet);\n    //        } else if (species == 32) {\n    //            (_Pet,) = _EvolveID53RQ(1,_Pet);  //Cut feature due to timeline for Hackathon\n            } else if (species == 30) {\n                (_Pet,) = _EvolveID57RQ(1,_Pet);\n            } else if (species == 37) {\n                (_Pet,) = _EvolveID54RQ(1,_Pet);\n    //        } else if (species == 27) {\n    //            (_Pet,) = _EvolveID49RQ(1,_Pet);\n            }\n        }\n        return _Pet;\n    }\n\n\n    //------------- Evolution Requirement -------------------\n    //------ Start from 10, 0 to 9 are basic and fixed via hatchegg function------\n//--------------- 10 to 22, 13 Rookies -----------------  20 Mature, 21 Perfect later\n//----------------  R O O K I E ----------------------------//\n           function _EvolveID10RQ(uint rand, A.Pets memory _Pet) private view //Wiggle\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<1,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.attribute.weight<1600   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 10; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,60000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,55);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,235);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,50);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainRookie);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),RookietoMatureTime);\n            _Pet.attribute.stage = 2; \n            _Pet.trait[0] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[0] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n      \n      function _EvolveID16RQ(uint rand, A.Pets memory _Pet) private view //Wingoid\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<13,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.attribute.weight<2500   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 16; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,60000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,80);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,144);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,112);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainRookie);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),RookietoMatureTime);\n            _Pet.attribute.stage = 2; \n            _Pet.trait[0] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[0] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n      function _EvolveID17RQ(uint rand, A.Pets memory _Pet) private view //IO-der\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<15,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.attribute.discipline>=150   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 17; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,140000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,100);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,80);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,100);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainRookie);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),RookietoMatureTime);\n            _Pet.attribute.stage = 2; \n            _Pet.trait[0] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[0] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n      function _EvolveID23RQ(uint rand, A.Pets memory _Pet) private view //Steelhead\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<27,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.power.agility>=180 &&\n     //       _Pet.attribute.happiness<=100   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 23; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,180000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,120);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,220);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,800);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainMature);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),MaturetoPerfectTime);\n            _Pet.attribute.stage = 3; \n            _Pet.trait[1] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[1] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n      function _EvolveID30RQ(uint rand, A.Pets memory _Pet) private view //Birdori\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<41,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.power.agility>=180 &&\n     //       _Pet.attribute.happiness>120 &&\n    //        _Pet.attribute.weight<7000   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 30; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,180000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,200);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,200);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,120);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainMature);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),MaturetoPerfectTime);\n            _Pet.attribute.stage = 3; \n            _Pet.trait[1] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[1] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n      function _EvolveID37RQ(uint rand, A.Pets memory _Pet) private view //Ointank\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<55,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.power.hitpoints>=180000   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 37; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,300000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,150);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,107);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,124);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainMature);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),MaturetoPerfectTime);\n            _Pet.attribute.stage = 3; \n            _Pet.trait[1] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[1] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n      function _EvolveID44RQ(uint rand, A.Pets memory _Pet) private view //Solanake\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<69,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.power.hitpoints>300000 &&\n    //        _Pet.power.agility>400 &&\n     //       _Pet.power.intellegence>200 &&\n     //       _Pet.attribute.discipline<50 &&\n     //       _Pet.attribute.weight>60000   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 44; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,176000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,198);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,220);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,200);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainPerfect);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),PerfecttoUnknownTime);\n            _Pet.attribute.stage = 4; \n            _Pet.trait[2] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[2] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n      function _EvolveID54RQ(uint rand, A.Pets memory _Pet) private view //Mechindragon\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<89,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.power.hitpoints>500000 &&\n     //       _Pet.power.strength>400 &&\n     //       _returnLevel(_Pet.exp)>40 &&\n     //       _Pet.attribute.weight>140000   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 54; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,245000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,209);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,178);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,200);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainPerfect);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),PerfecttoUnknownTime);\n            _Pet.attribute.stage = 4; \n            _Pet.trait[2] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[2] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n      function _EvolveID57RQ(uint rand, A.Pets memory _Pet) private view //Feroth\n                                returns (A.Pets memory, bool MeetRQ){\n        //if (_RandNumb(rand<<95,4,0) < 3 && //60% chance to evolve to this\n          //  _Pet.power.hitpoints>400000 &&\n     //       _Pet.power.strength>300 &&\n      //      _Pet.power.intellegence>350 &&\n      //      _returnLevel(_Pet.exp)>23 &&\n      //      _Pet.attribute.happiness<50   ) { //check meet evolve condition?\n         //   MeetRQ = true;\n            _Pet.species = 57; //set to new species\n            //uint8 geneSynapse = add9L(_getGene(_Pet.gene,_Pet.species),1); //increase the geneSynapse based on new species\n            //_Pet.gene = _setGene(_Pet.gene,_Pet.species+1,geneSynapse); //order always +1 from Species(start with 0), set it    \n            //----evolve bonus\n            _Pet.power.hitpoints = add32b(_Pet.power.hitpoints,190000);\n            _Pet.power.strength = add16B999L(_Pet.power.strength,233);\n            _Pet.power.agility = add16B999L(_Pet.power.agility,166);\n            _Pet.power.intellegence = add16B999L(_Pet.power.intellegence,233);\n            _Pet.time.deadtime = add64b(_Pet.time.deadtime,lifeGainPerfect);\n            _Pet.time.evolutiontime = add64b(uint64(block.timestamp),PerfecttoUnknownTime);\n            _Pet.attribute.stage = 4; \n            _Pet.trait[2] = uint8(_RandNumb(rand<<6,31,1));      //evolve gain 1 random trait\n            _Pet.skill[2] = _Pet.species;      //evolve gain 1 skill/////////////////////////<----- which is its own ID example 10\n        //} else { //evolve fail\n         //   MeetRQ = false;\n //       }\n        return (_Pet,MeetRQ);\n    }\n  \n\n\n}\n"},"contracts/base64.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/token/ERC721/extensions/IERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"},"@openzeppelin/contracts@4.7.0/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/utils/Strings.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"@openzeppelin/contracts@4.7.0/token/ERC721/extensions/IERC721Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"},"@openzeppelin/contracts@4.7.0/token/ERC721/IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"@openzeppelin/contracts@4.7.0/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":1},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]}}
